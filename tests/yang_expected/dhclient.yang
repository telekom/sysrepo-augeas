module dhclient {
  namespace "aug:dhclient";
  prefix aug;

  import augeas-extension {
    prefix augex;
  }

  augex:augeas-mod-name "Dhclient";

  grouping stmt_opt_mod {
    container word {
      augex:data-path "$$";
      augex:value-yang-path "sto_to_spc_noeval";
      presence "Type of config entry.";
      leaf word {
        mandatory true;
        type string {
          pattern "[A-Za-z0-9_.-]+(\\[[0-9]+\\])?";
        }
      }
      leaf sto_to_spc_noeval {
        type string {
          pattern "[^=\\#,;{}\" \t\n]|[^=\\#,;{}\" \t\n][^\\#,;{}\" \t\n]*|\"[^\\#\"\n]+\"";
        }
      }
      choice ch_word {
        mandatory true;
        container node {
          leaf code {
            mandatory true;
            type string {
              pattern "[A-Za-z0-9_.-]+(\\[[0-9]+\\])?";
            }
            augex:data-path "code";
          }
          leaf value {
            mandatory true;
            type string {
              pattern "[^ \t\n][^;\n]+[^ \t]|[^ \t;\n]+";
            }
            augex:data-path "value";
          }
        }
        leaf eval {
          type string {
            pattern "[^ \t\n][^;\n]+[^ \t]|[^ \t;\n]+";
          }
          augex:data-path "#eval";
        }
      }
    }
  }
  grouping stmt_array {
    list config-entries {
      key "_id";
      ordered-by user;
      leaf _id {
        type uint64;
        description
          "Implicitly generated list key to maintain the order of the augeas data.";
      }
      container stmt_array {
        augex:data-path "$$";
        augex:value-yang-path "sto_to_spc";
        presence "Config entry.";
        leaf stmt_array {
          mandatory true;
          type uint64;
        }
        leaf sto_to_spc {
          mandatory true;
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
        }
      }
    }
  }
  grouping stmt_block {
    list config-entries {
      key "_id";
      ordered-by user;
      leaf _id {
        type uint64;
        description
          "Implicitly generated list key to maintain the order of the augeas data.";
      }
      choice ch_config-entries {
        mandatory true;
        container media {
          augex:data-path "media";
          presence "Type of config entry.";
          uses stmt_array;
        }
        container request {
          augex:data-path "request";
          presence "Type of config entry.";
          uses stmt_array;
        }
        container require {
          augex:data-path "require";
          presence "Type of config entry.";
          uses stmt_array;
        }
        container send {
          augex:data-path "send";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container option {
          augex:data-path "option";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container append {
          augex:data-path "append";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container prepend {
          augex:data-path "prepend";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container default {
          augex:data-path "default";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container supersede {
          augex:data-path "supersede";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        leaf interface {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "interface";
        }
        leaf script {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "script";
        }
        leaf bootp {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "bootp";
        }
        leaf fixed-address {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "fixed-address";
        }
        leaf filename {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "filename";
        }
        leaf server-name {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "server-name";
        }
        leaf medium {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "medium";
        }
        leaf vendor_option_space {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "vendor option space";
        }
        container renew {
          augex:data-path "renew";
          presence "Type of config entry.";
          uses stmt_block_date;
        }
        container rebind {
          augex:data-path "rebind";
          presence "Type of config entry.";
          uses stmt_block_date;
        }
        container expire {
          augex:data-path "expire";
          presence "Type of config entry.";
          uses stmt_block_date;
        }
      }
    }
  }
  grouping stmt_block_date {
    leaf weekday {
      mandatory true;
      type string {
        pattern "[0-9][0-9]*";
      }
      augex:data-path "weekday";
    }
    leaf year {
      mandatory true;
      type string {
        pattern "[0-9][0-9]*";
      }
      augex:data-path "year";
    }
    leaf month {
      mandatory true;
      type string {
        pattern "[0-9][0-9]*";
      }
      augex:data-path "month";
    }
    leaf day {
      mandatory true;
      type string {
        pattern "[0-9][0-9]*";
      }
      augex:data-path "day";
    }
    leaf hour {
      mandatory true;
      type string {
        pattern "[0-9][0-9]*";
      }
      augex:data-path "hour";
    }
    leaf minute {
      mandatory true;
      type string {
        pattern "[0-9][0-9]*";
      }
      augex:data-path "minute";
    }
    leaf second {
      mandatory true;
      type string {
        pattern "[0-9][0-9]*";
      }
      augex:data-path "second";
    }
  }
  list dhclient {
    key "config-file";
    leaf config-file {
      type string;
    }
    list config-entries {
      key "_id";
      ordered-by user;
      leaf _id {
        type uint64;
        description
          "Implicitly generated list key to maintain the order of the augeas data.";
      }
      choice ch_config-entries {
        mandatory true;
        leaf timeout {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "timeout";
        }
        leaf retry {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "retry";
        }
        leaf select-timeout {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "select-timeout";
        }
        leaf reboot {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "reboot";
        }
        leaf backoff-cutoff {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "backoff-cutoff";
        }
        leaf initial-interval {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "initial-interval";
        }
        leaf do-forward-updates {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "do-forward-updates";
        }
        leaf reject {
          type string {
            pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
          }
          augex:data-path "reject";
        }
        container append {
          augex:data-path "append";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container prepend {
          augex:data-path "prepend";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container default {
          augex:data-path "default";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container supersede {
          augex:data-path "supersede";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container media {
          augex:data-path "media";
          presence "Type of config entry.";
          uses stmt_array;
        }
        container request {
          augex:data-path "request";
          presence "Type of config entry.";
          uses stmt_array;
        }
        container require {
          augex:data-path "require";
          presence "Type of config entry.";
          uses stmt_array;
        }
        container send {
          augex:data-path "send";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container option {
          augex:data-path "option";
          presence "Type of config entry.";
          uses stmt_opt_mod;
        }
        container interface {
          augex:data-path "interface";
          augex:value-yang-path "sto_to_spc";
          presence "Type of config entry.";
          leaf sto_to_spc {
            type string {
              pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
            }
          }
          uses stmt_block;
        }
        container lease {
          augex:data-path "lease";
          augex:value-yang-path "sto_to_spc";
          presence "Type of config entry.";
          leaf sto_to_spc {
            type string {
              pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
            }
          }
          uses stmt_block;
        }
        container alias {
          augex:data-path "alias";
          augex:value-yang-path "sto_to_spc";
          presence "Type of config entry.";
          leaf sto_to_spc {
            type string {
              pattern "[^\\#,;{}\" \t\n]+|\"[^\\#\"\n]+\"";
            }
          }
          uses stmt_block;
        }
      }
    }
  }
}
